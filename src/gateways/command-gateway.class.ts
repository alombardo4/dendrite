import { CommandHandler, BaseCommand, CommandExecutionContext } from '../';

export class CommandGateway {

  private commandHandlerMappings: Map<string, CommandHandler<any>>;

  constructor(commandHandlers: CommandHandler<any>[]) {
    this.commandHandlerMappings = new Map();
    for (let i = 0; i < commandHandlers.length; i++) {
      this.register(commandHandlers[i]);
    }
  }

  /**
   * Registers a command handler. If a handler already exists with the given identifer, it is ignored.
   * @param handler The command handler to register
   */
  register(handler: CommandHandler<any>): void {
    if (this.commandHandlerMappings.get(handler.identifier)) {
      console.error(`A command handler with identifer ${handler.identifier} has already been registerd. Aborting!`);
    } else {
      this.commandHandlerMappings.set(handler.identifier, handler);
    }
  }

  /**
   * Synchronous command gateway "send" function. This function will dispatch the passed command to the relevant command handler.
   * @throws No handler errors - Thrown when a required handler was not registered.
   * @throws Upstream handler errors - errors generated by a registered command handler.
   * @param command The command to send
   * @returns boolean - Whether the execution was successful or not
   */
  sendAndWait(command: BaseCommand): boolean {
    const handler = this.commandHandlerMappings.get(command.identifier);
    if (!handler) {
      console.error('No handler found! Aborting!');
      throw new Error(`No handler found for command with identifer ${command.identifier}`);
    }
    const executionContext = new CommandExecutionContext(command);
    return handler.handle(executionContext);
  }

  /**
   * Asynchronous command gatway "send" function. It will dispatch the passed command and swallow any errors. USE WITH CAUTION
   * @param command The command to send
   */
  send(command: BaseCommand): void {
    setTimeout(() => {
      this.sendAndWait(command);
    });
  }
}